<html>

<head>
	<title>McLaren Track Viewer (MTV) Homage</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DV9BF3P4RZ"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-DV9BF3P4RZ');
	</script>
	<meta name='impact-site-verification' value='b579a4b5-b177-40c2-a363-59b57f39997b'>
	<script src="./topnav.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="./style.css">
</head>

<body>

	<canvas id="mtv">
	</canvas>
	<canvas id="tv">
	</canvas>

	<script src="mtv-data.js"></script>
	<script>

		let min_x = 10000000;
		let min_y = 10000000;
		let max_x = -10000000;
		let max_y = -10000000;
		for (let idx = 0; idx < location_data.length; idx += 1) {
			const x = location_data[idx]['x'];
			const y = location_data[idx]['y'];
			if (x < min_x) {
				min_x = x;
			}
			if (x > max_x) {
				max_x = x;
			}
			if (y < min_y) {
				min_y = y;
			}
			if (y > max_y) {
				max_y = y;
			}
		}
		console.log('bounding box [' + min_x + ',' + min_y + '->' + max_x + ',' + max_y + ']');
		const native_width = max_x - min_x;
		const native_height = max_y - min_y;
		const native_aspect_ratio = native_width / native_height;

		driver_info = {}
		for (let idx = 0; idx < driver_data.length; idx += 1) {
			driver_info[driver_data[idx]['driver_number']] = driver_data[idx];
		}


		//year->race name->driver->lap
		//picker will let you choose race/lap,
		//which will give us session_key, date
		//
		// let's hardcode 2024, miami, hamilton, 14
		//https://api.openf1.org/v1/laps?session_key=9507&driver_number=44&lap_number=14
		//rv has date_start and lap_duration, compute date_end

		const driver_to_track = lap_data[0]["driver_number"];

		track_outline = []
		for (let idx = 0; idx < location_data.length; idx += 1) {
			if (location_data[idx]['driver_number'] == driver_to_track) {
				track_outline.push({ x: location_data[idx]['x'], y: location_data[idx]['y'] });
			}
		}

		const date_start = new Date(lap_data[0]['date_start']);
		//lap_duration: 93.693
		let date_end = new Date(lap_data[0]['date_start']);
		date_end.setMilliseconds(date_end.getMilliseconds() + (lap_data[0]['lap_duration'] * 1000));


		//SHORT: const date_end = "2024-05-05T20:24:28.049000+00:00";
		//   - interval data
		//https://api.openf1.org/v1/intervals?session_key=9507&date>DATE_START&date<DATE_END
		//   - location data
		//https://api.openf1.org/v1/location?session_key=9507&date>DATE_START&date<DATE_END		
		//   - driver data (colors, 3letter)
		//https://api.openf1.org/v1/drivers?session_key=9507
		//
		//that should be all the data
		//then we start the clock
		//  ...and keep head on interval and location
		//  ...and maintain the latest_known for each display


		window.addEventListener('resize', handleResize);

		const mtv_canvas = document.getElementById('mtv');
		const mtv_ctx = mtv_canvas.getContext('2d');

		const tv_canvas = document.getElementById('tv');
		const tv_ctx = tv_canvas.getContext('2d');

		mtv_ctx.canvas.width = window.innerWidth / 2.0;
		tv_ctx.canvas.width = window.innerWidth / 2.0;

		const canvas_height = window.innerHeight;
		mtv_ctx.canvas.height = canvas_height;
		tv_ctx.canvas.height = canvas_height;

		let tv_aspect_ratio = tv_ctx.canvas.width / tv_ctx.canvas.height;

		function handleResize() {
			const canvas_height = (window.innerHeight);
			document.getElementById('mtv').width = window.innerWidth / 2.0;
			document.getElementById('mtv').height = canvas_height;
			document.getElementById('tv').width = window.innerWidth / 2.0;
			document.getElementById('tv').height = canvas_height;
			tv_aspect_ratio = window.innerWidth / 2.0 / canvas_height;
		}

		function draw_line(ctx, radius, angle, length, color, driver_number, cyan_ball) {

			const centerX = ctx.canvas.width / 2;
			const centerY = ctx.canvas.height / 2;
			const lineLength = radius + (length / 2); // Extend beyond the circle

			const lineStartX = centerX + (lineLength - length) * Math.cos(angle);
			const lineStartY = centerY + (lineLength - length) * Math.sin(angle);

			const lineEndX = centerX + lineLength * Math.cos(angle);
			const lineEndY = centerY + lineLength * Math.sin(angle);

			if (cyan_ball) {
				//draw cyan ball
				//#00FFFF
				ctx.beginPath();
				ctx.arc(
					centerX + (lineLength - length / 2) * Math.cos(angle),
					centerY + (lineLength - length / 2) * Math.sin(angle),
					10, 0, 2 * Math.PI, false);
				ctx.strokeStyle = 'gray';
				ctx.lineWidth = 2;
				ctx.fillStyle = '#00FFFF';
				ctx.fill();
				ctx.stroke();
				return;
			}

			// Draw the perpendicular line segment
			ctx.beginPath();
			ctx.moveTo(lineStartX, lineStartY); // Start from the center of the circle
			ctx.lineTo(lineEndX, lineEndY);
			ctx.strokeStyle = '#' + color;
			if (driver_number) {
				ctx.lineWidth = 4;
			} else {
				ctx.lineWidth = 2;
			}
			ctx.closePath();
			ctx.stroke();
			ctx.beginPath();

			if (driver_number) {

				const text_target_gap = 40;

				const targetStartX = centerX + (lineLength + text_target_gap - length) * Math.cos(angle);
				const targetStartY = centerY + (lineLength + text_target_gap - length) * Math.sin(angle);

				const targetEndX = centerX + (lineLength + text_target_gap) * Math.cos(angle);
				const targetEndY = centerY + (lineLength + text_target_gap) * Math.sin(angle);

				const text = driver_info[driver_number]['name_acronym'];
				const metrics = mtv_ctx.measureText(text);

				ctx.fillStyle = "white";
				ctx.fillText(text,
					targetStartX - (metrics.width / 2),
					targetStartY + (metrics.fontBoundingBoxAscent / 2));

			}
		}

		function animate_mtv(intervals_state, cur_time, date_cur_time) {

			// Clear the canvas
			mtv_ctx.fillStyle = "#000000";
			mtv_ctx.fillRect(0, 0, mtv_canvas.width, mtv_canvas.height);

			const centerX = mtv_ctx.canvas.width / 2;
			const centerY = mtv_ctx.canvas.height / 2;
			const radius = Math.min(centerX / 1.5, centerY / 1.5);

			mtv_ctx.fillStyle = "white";
			mtv_ctx.font = '14px sans-serif';
			const text = 'Lap ' + lap_data[0]['lap_number'];
			const metrics = mtv_ctx.measureText(text);
			mtv_ctx.fillText(text, centerX - (metrics.width / 2), centerY - metrics.fontBoundingBoxAscent);
			const formattedTime = date_cur_time.toLocaleTimeString('en-US', {
				hour: '2-digit',
				minute: '2-digit',
				second: '2-digit',
				hour12: false // Use 24-hour format for consistency
			});

			// Get the milliseconds
			const milliseconds = date_cur_time.getMilliseconds();

			// Pad milliseconds with leading zeros if needed
			const paddedMilliseconds = String(milliseconds).padStart(3, '0');

			// Combine the formatted time and milliseconds
			const fullTimeWithMillis = `${formattedTime}.${paddedMilliseconds}`;
			const metrics_time = mtv_ctx.measureText(fullTimeWithMillis);
			mtv_ctx.fillText(fullTimeWithMillis, centerX - (metrics_time.width / 2), centerY);


			mtv_ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
			mtv_ctx.lineWidth = 20;
			mtv_ctx.strokeStyle = 'gray';
			mtv_ctx.stroke();
			mtv_ctx.beginPath();


			draw_line(mtv_ctx, radius, Math.PI * 3 / 2, 65, '32CD32', null);

			draw_line(mtv_ctx, radius,
				(lap_data[0]['duration_sector_1'] / lap_data[0]['lap_duration']) * Math.PI * 2
				-
				(Math.PI / 2),
				65, '32CD32', null);

			draw_line(mtv_ctx, radius,
				((lap_data[0]['duration_sector_1'] + lap_data[0]['duration_sector_2']) / lap_data[0]['lap_duration']) * Math.PI * 2
				-
				(Math.PI / 2),
				65, '32CD32', null);

			//duration_sector_1
			//duration_sector_2
			//lap_duration

			draw_line(mtv_ctx, radius,
				((Math.PI * 2 * (running_clock - 22.0))
					/
					lap_data[0]['lap_duration'])
				-
				(Math.PI / 2.0),
				20, driver_info[driver_to_track]['team_colour'], driver_to_track, true);



			Object.keys(interval_state).forEach(function (driver_number) {
				if (driver_to_track in interval_state) {
					if (driver_number != driver_to_track) {
						draw_line(mtv_ctx, radius,
							((Math.PI * 2 * (running_clock
								+
								(interval_state[driver_to_track]
									-
									interval_state[driver_number]
								)))
								/
								lap_data[0]['lap_duration'])
							-
							(Math.PI / 2.0),
							20, driver_info[driver_number]['team_colour'], driver_number);
					}
				} else {
					/* this was logic to handle when leader is driver_to_track
					if (driver_number != driver_to_track) {
						draw_line(mtv_ctx, radius,
							((Math.PI * 2 * (running_clock
								-
								interval_state[driver_number]
							))
								/
								lap_data[0]['lap_duration'])
							-
							(Math.PI / 2.0),
							20, driver_info[driver_number]['team_colour'], driver_number);
					}
					*/

				}
			});
			draw_line(mtv_ctx, radius,
				((Math.PI * 2 * (running_clock))
					/
					lap_data[0]['lap_duration'])
				-
				(Math.PI / 2.0),
				20, 'FF00FF', driver_to_track, false);

		}

		const hborder = 25;
		const vborder = 75;

		function translate_to_tv_canvas(x, y) {
			if (native_aspect_ratio < tv_aspect_ratio) {
				const scale_factor_based_on_height = ((tv_ctx.canvas.height - (2 * vborder)) / native_height);
				const scaled_width = native_width * scale_factor_based_on_height;
				let rx = x;
				let ry = y;
				rx += (-min_x);
				ry += (-min_y);
				rx = rx * scale_factor_based_on_height;
				ry = ry * scale_factor_based_on_height;
				rx = rx + (((tv_ctx.canvas.width - (2.0 * hborder)) - scaled_width) / 2.0);
				rx += hborder;
				ry += vborder;
				ry = tv_ctx.canvas.height - ry;
				return [rx, ry];
			} else {
				const scale_factor_based_on_width = ((tv_ctx.canvas.width - (2 * hborder)) / native_width);
				const scaled_height = native_height * scale_factor_based_on_width;
				let rx = x;
				let ry = y;
				rx += (-min_x);
				ry += (-min_y);
				rx = rx * scale_factor_based_on_width;
				ry = ry * scale_factor_based_on_width;
				ry = ry + (((tv_ctx.canvas.height - (2.0 * vborder)) - scaled_height) / 2.0);
				rx += hborder;
				ry += vborder;
				ry = tv_ctx.canvas.height - ry;
				return [rx, ry];
			}
		}

		function animate_tv(locations_state) {

			// Clear the canvas
			tv_ctx.fillStyle = "#000000";
			tv_ctx.fillRect(0, 0, tv_canvas.width, tv_canvas.height);

			//draw track
			tv_ctx.beginPath();
			let [draw_x, draw_y] = translate_to_tv_canvas(track_outline[0]['x'], track_outline[0]['y']);
			tv_ctx.moveTo(draw_x, draw_y);
			for (idx = 1; idx < track_outline.length; idx += 1) {
				[draw_x, draw_y] = translate_to_tv_canvas(track_outline[idx]['x'], track_outline[idx]['y']);
				tv_ctx.lineTo(draw_x, draw_y);
			}
			[draw_x, draw_y] = translate_to_tv_canvas(track_outline[0]['x'], track_outline[0]['y']);
			tv_ctx.lineTo(draw_x, draw_y);
			tv_ctx.strokeStyle = "gray";
			tv_ctx.lineWidth = 9;
			tv_ctx.stroke();

			Object.keys(location_state).forEach(function (driver_number) {

				let [draw_x, draw_y] = translate_to_tv_canvas(location_state[driver_number][0], location_state[driver_number][1]);
				tv_ctx.beginPath();
				tv_ctx.arc(draw_x, draw_y, 5, 0, 2 * Math.PI, false);
				tv_ctx.strokeStyle = 'black';
				tv_ctx.lineWidth = 2;
				tv_ctx.fillStyle = '#' + driver_info[driver_number]['team_colour']; //
				tv_ctx.fill();
				tv_ctx.stroke();
				tv_ctx.fillText(driver_info[driver_number]['name_acronym'], draw_x + 10, draw_y - 15);
			});
		}
		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		let interval_state = {};
		let location_state = {};
		let running_clock = 0.0;
		const increment = .01;

		async function do_the_things_and_wait(p_cur_time, p_date_date_end, p_interval_idx, p_location_idx) {

			let m_interval_idx = p_interval_idx;
			let m_location_idx = p_location_idx;

			//TODO: will barf if internal falls off end
			while (new Date(interval_data[m_interval_idx]['date']) < p_cur_time) {
				interval_state[interval_data[m_interval_idx]['driver_number']] = interval_data[m_interval_idx]['gap_to_leader'];
				//TODO: this could fall off end
				m_interval_idx += 1;
			}
			while (new Date(location_data[m_location_idx]['date']) < p_cur_time) {
				location_state[location_data[m_location_idx]['driver_number']] = [location_data[m_location_idx]['x'], location_data[m_location_idx]['y']];
				//TODO: this could fall off end
				m_location_idx += 1;
			}

			animate_mtv(interval_state, running_clock, p_cur_time);
			animate_tv(location_state);
			running_clock += increment;

			if (p_cur_time > date_end) {
				//console.log('exiting do_the_things');
			} else {
				p_cur_time.setMilliseconds(p_cur_time.getMilliseconds() + (increment * 1000));
				//await sleep(increment * 1000);
				await sleep(9);
				do_the_things_and_wait(p_cur_time, p_date_date_end, m_interval_idx, m_location_idx);
			}
		}

		do_the_things_and_wait(date_start, date_end, 0, 0);
		//animate_mtv(interval_state);
		//animate_tv(location_state);

		//console.log(interval_data[0].date);
		//console.log(location_data[0].date);

	</script>

	<!-- Top Navigation Menu -->

	<div class="topnav">
		<a href="javascript:void(0);" class="active">
			<h1>McLaren Track Viewer (MTV) Homage</h1>
		</a>
		<!-- Navigation links (hidden by default) -->
		<!-- <script src="./grid.js"></script> -->
		<div id="myLinks">
			<a href="javascript:void(0);" onclick="showAbout();">About</a>
			<a href="javascript:void(0);" onclick="showDisclaimer();">Disclaimer</a>
		</div>
		<!-- "Hamburger menu" / "Bar icon" to toggle the navigation links -->
		<a href="javascript:void(0);" class="icon" onclick="myFunction();">
			<i class="fa fa-bars"></i>
		</a>
	</div>
	<div class="content">
		<p>This page shows a modern recreation of the MTV. A blog post describing this tool is <a
				href="https://dev.to/datadr1ven/leveraging-redis-80s-new-time-series-capabilities-in-a-real-time-formula-1-dashboard-p6b">here
			</a>
		</p>
	</div>
</body>

</html>